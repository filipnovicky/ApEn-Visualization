const N_analysis = 10;
  const N_display = 50;import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, SkipBack, SkipForward } from 'lucide-react';

const ApproximateEntropyAnimation = () => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [selectedM, setSelectedM] = useState(2);
  const [currentM, setCurrentM] = useState(2);
  const [highlightIndex, setHighlightIndex] = useState(0);
  const [showMatrix, setShowMatrix] = useState(false);
  const [alpha, setAlpha] = useState(0.2);
  const [noiseLevel, setNoiseLevel] = useState(0.1);
  const intervalRef = useRef(null);

  // Generate the two signals
  const generateRegularSignal = () => {
    const signal = [];
    const period = 20;
    for (let i = 0; i < 150; i++) {
      const phase = (i % period) / period;
      let value;
      if (phase < 0.5) {
        value = -0.5 + 2 * phase;
      } else {
        value = 0.5 - 2 * (phase - 0.5);
      }
      // Add noise to regular signal
      value += (Math.random() - 0.5) * 2 * noiseLevel;
      signal.push(value);
    }
    return signal;
  };

  const generateNoiseSignal = () => {
    const signal = [];
    for (let i = 0; i < 150; i++) {
      signal.push((Math.random() - 0.5));
    }
    return signal;
  };

  const [regularSignal, setRegularSignal] = useState(generateRegularSignal());
  const [noiseSignal, setNoiseSignal] = useState(generateNoiseSignal());

  // Regenerate signals when noise level changes
  useEffect(() => {
    setRegularSignal(generateRegularSignal());
    setNoiseSignal(generateNoiseSignal());
  }, [noiseLevel]);

  // Calculate standard deviation of the signal
  const calculateSD = (signal) => {
    const mean = signal.reduce((sum, val) => sum + val, 0) / signal.length;
    const variance = signal.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / signal.length;
    return Math.sqrt(variance);
  };

  // Calculate r = α × SD for each signal
  const regularSD = calculateSD(regularSignal.slice(0, N_display));
  const noiseSD = calculateSD(noiseSignal.slice(0, N_display));
  const regularR = alpha * regularSD;
  const noiseR = alpha * noiseSD;

  // Find similar patterns using Chebyshev distance
  const findSimilarPatterns = (signal, startIndex, m, r) => {
    if (startIndex >= N_analysis - m + 1) return [];
    
    const currentPattern = signal.slice(startIndex, startIndex + m);
    const similarPatterns = [];
    
    for (let i = 0; i <= N_display - m; i++) {
      const comparePattern = signal.slice(i, i + m);
      
      let chebyshevDistance = 0;
      for (let j = 0; j < m; j++) {
        const diff = Math.abs(currentPattern[j] - comparePattern[j]);
        chebyshevDistance = Math.max(chebyshevDistance, diff);
      }
      
      if (chebyshevDistance <= r) {
        similarPatterns.push(i);
      }
    }
    return similarPatterns;
  };

  // Create pattern repetition counts vector
  const createPatternCounts = (signal, m, r) => {
    const analysisPatterns = N_analysis - m + 1;
    const counts = [];
    
    for (let i = 0; i < analysisPatterns; i++) {
      const similarPatterns = findSimilarPatterns(signal, i, m, r);
      counts.push(similarPatterns.length);
    }
    return counts;
  };

  // Compute approximate entropy
  const computeApEn = (signal, m, r) => {
    const numPatterns = N_analysis - m + 1;
    const totalPossiblePatterns = N_display - m + 1; // All possible patterns in the full signal
    let phi = 0;
    
    for (let i = 0; i < numPatterns; i++) {
      const similarPatterns = findSimilarPatterns(signal, i, m, r);
      const C = similarPatterns.length / totalPossiblePatterns; // Normalize by all possible patterns
      if (C > 0) {
        phi += Math.log(C);
      }
    }
    
    return phi / numPatterns;
  };

  const regularSimilar = findSimilarPatterns(regularSignal, highlightIndex, currentM, regularR);
  const noiseSimilar = findSimilarPatterns(noiseSignal, highlightIndex, currentM, noiseR);

  // Compute ApEn for selected m and m+1
  const regularPhiM = computeApEn(regularSignal, selectedM, regularR);
  const regularPhiM1 = computeApEn(regularSignal, selectedM + 1, regularR);
  const regularApEn = regularPhiM - regularPhiM1;

  const noisePhiM = computeApEn(noiseSignal, selectedM, noiseR);
  const noisePhiM1 = computeApEn(noiseSignal, selectedM + 1, noiseR);
  const noiseApEn = noisePhiM - noisePhiM1;

  const regularCountsM = createPatternCounts(regularSignal, selectedM, regularR);
  const noiseCountsM = createPatternCounts(noiseSignal, selectedM, noiseR);
  const regularCountsM1 = createPatternCounts(regularSignal, selectedM + 1, regularR);
  const noiseCountsM1 = createPatternCounts(noiseSignal, selectedM + 1, noiseR);

  useEffect(() => {
    if (isPlaying) {
      intervalRef.current = setInterval(() => {
        setHighlightIndex(prev => {
          const next = prev + 1;
          const maxIndex = N_analysis - currentM;
          if (next >= maxIndex) {
            if (currentM === selectedM) {
              setCurrentM(selectedM + 1);
              return 0;
            } else {
              setShowMatrix(true);
              setIsPlaying(false);
              return 0;
            }
          }
          return next;
        });
      }, 1000);
    } else {
      clearInterval(intervalRef.current);
    }
    return () => clearInterval(intervalRef.current);
  }, [isPlaying, currentM, selectedM]);

  const togglePlay = () => setIsPlaying(!isPlaying);
  const reset = () => {
    setHighlightIndex(0);
    setCurrentM(selectedM);
    setShowMatrix(false);
    setIsPlaying(false);
  };

  const stepForward = () => {
    if (showMatrix) return;
    
    const maxIndex = N_analysis - currentM;
    if (highlightIndex + 1 >= maxIndex) {
      if (currentM === selectedM) {
        setCurrentM(selectedM + 1);
        setHighlightIndex(0);
      } else {
        setShowMatrix(true);
      }
    } else {
      setHighlightIndex(prev => prev + 1);
    }
  };

  const stepBackward = () => {
    if (showMatrix) {
      setShowMatrix(false);
      setCurrentM(selectedM + 1);
      setHighlightIndex(N_analysis - (selectedM + 1) - 1);
      return;
    }
    
    if (highlightIndex > 0) {
      setHighlightIndex(prev => prev - 1);
    } else if (currentM === selectedM + 1) {
      setCurrentM(selectedM);
      setHighlightIndex(N_analysis - selectedM - 1);
    }
  };

  const SignalPlot = ({ signal, title, color, similarIndices }) => (
    <div className="mb-4">
      <h4 className="text-sm font-medium mb-2">{title}</h4>
      <div className="relative h-24 bg-gray-50 border rounded">
        <svg width="100%" height="100%" viewBox="0 0 300 96">
          <polyline
            points={signal.slice(0, N_display).map((val, i) => `${i * 6},${48 - val * 70}`).join(' ')}
            fill="none"
            stroke={color}
            strokeWidth="1.5"
          />
          
          <rect
            x="0"
            y="5"
            width={N_analysis * 6}
            height="86"
            fill="rgba(0,100,255,0.1)"
            stroke="rgba(0,100,255,0.3)"
            strokeWidth="1"
            strokeDasharray="3,3"
          />
          <text
            x={N_analysis * 3}
            y={20}
            textAnchor="middle"
            fontSize="9"
            fill="#0066ff"
            fontWeight="bold"
          >
            Analysis Window
          </text>
          
          {!showMatrix && similarIndices.filter(idx => idx !== highlightIndex).map(idx => (
            <g key={idx}>
              <polyline
                points={signal.slice(idx, idx + currentM)
                  .map((val, i) => `${(idx + i) * 6},${48 - val * 70}`).join(' ')}
                fill="none"
                stroke="#10b981"
                strokeWidth="4"
                opacity="0.8"
              />
              {signal.slice(idx, idx + currentM).map((val, i) => (
                <circle
                  key={i}
                  cx={(idx + i) * 6}
                  cy={48 - val * 70}
                  r="2.5"
                  fill="#10b981"
                  stroke="white"
                  strokeWidth="1"
                />
              ))}
            </g>
          ))}
          
          {!showMatrix && highlightIndex < N_analysis - currentM + 1 && (
            <>
              <polyline
                points={signal.slice(highlightIndex, highlightIndex + currentM)
                  .map((val, i) => `${(highlightIndex + i) * 6},${48 - val * 70}`).join(' ')}
                fill="none"
                stroke="#ff6b35"
                strokeWidth="4"
              />
              
              {signal.slice(highlightIndex, highlightIndex + currentM).map((val, i) => (
                <circle
                  key={i}
                  cx={(highlightIndex + i) * 6}
                  cy={48 - val * 70}
                  r="4"
                  fill="#ff6b35"
                  stroke="white"
                  strokeWidth="1"
                />
              ))}
              
              <text
                x={(highlightIndex + (currentM-1)/2) * 6}
                y={35}
                textAnchor="middle"
                fontSize="11"
                fill="#ff6b35"
                fontWeight="bold"
              >
                Current
              </text>
            </>
          )}
          
          <line x1="0" y1="48" x2="300" y2="48" stroke="#ddd" strokeWidth="1" />
        </svg>
      </div>
      {!showMatrix && (
        <div className="text-xs mt-1 text-center">
          <span className="text-orange-600 font-medium">Pattern {highlightIndex + 1}: Current pattern from analysis window</span>
          {similarIndices.length > 1 && (
            <span className="ml-4 text-green-600 font-medium">
              Similar patterns to Pattern {highlightIndex + 1}: {similarIndices.length - 1} matches found
            </span>
          )}
        </div>
      )}
    </div>
  );

  return (
    <div className="max-w-6xl mx-auto p-6 bg-white">
      <h2 className="text-2xl font-bold mb-6 text-center">
        Visualization of Approximate Entropy Analysis
      </h2>

      {/* Motivation Section */}
      <div className="mb-8 p-6 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border-l-4 border-blue-500">
        <h3 className="text-xl font-bold mb-4 text-gray-800">
          How do you measure the regularity of a signal when you don't know what function it follows?
        </h3>
        
        <div className="space-y-4 text-gray-700">
          <p className="text-base leading-relaxed">
            Consider analyzing <strong>sensor data from a complex dynamical system</strong> - perhaps temperature 
            fluctuations in a chemical reactor, stock market prices, seismic activity recordings, or electrophysiological signals. 
            These signals appear intricate and unpredictable, yet some may contain underlying regularities 
            while others are purely chaotic.
          </p>
          
          <p className="text-base leading-relaxed">
            <strong>Approximate Entropy (ApEn)</strong> addresses this challenge by quantifying pattern regularity 
            without requiring knowledge of the underlying mathematical function the system can be described with. Even when we cannot understand 
            the specific mechanisms generating the signal, we can assess whether there is some inherent regularity 
            or randomness - something that can be informative about the complexity of the system.
          </p>

          <div className="bg-white p-4 rounded border-l-4 border-purple-400">
            <h4 className="font-semibold mb-2 text-purple-800">What you'll explore:</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
              <div>
                <p><strong>Signal A (Red):</strong> Random fluctuations - irregular, unpredictable patterns</p>
                <p><strong>Signal B (Blue):</strong> Periodic oscillations - regular, repeating patterns</p>
              </div>
              <div>
                <p><strong>Pattern Length:</strong> Number of consecutive points in each pattern (m = {selectedM})</p>
                <p><strong>Alpha (α):</strong> Scaling factor for adaptive tolerance (r = α × standard deviation (SD))</p>
                <p><strong>Noise Level:</strong> Add noise to the regular recording</p>
              </div>
            </div>
          </div>

          <div className="bg-white p-4 rounded border-l-4 border-green-400">
            <h4 className="font-semibold mb-2 text-green-800">Interactive Exploration:</h4>
            <p className="text-sm text-gray-700">
              Try to figure out how different parameters affect the analysis! Does the analysis still work properly when collected data are noisy? Does it help to increase α or m to combat noise? Can you explain why?
            </p>
          </div>
        </div>
      </div>

      {/* Parameter Controls */}
      <div className="flex justify-center gap-6 mb-4 p-4 bg-gray-50 rounded">
        <div className="flex items-center gap-2">
          <label className="text-sm font-medium">Pattern Length:</label>
          <input
            type="range"
            min="2"
            max="5"
            step="1"
            value={selectedM}
            onChange={(e) => {
              const newM = parseInt(e.target.value);
              setSelectedM(newM);
              setCurrentM(newM);
              setShowMatrix(false);
              setHighlightIndex(0);
            }}
            className="w-24"
          />
          <span className="text-sm font-mono w-12">m = {selectedM}</span>
        </div>
        <div className="flex items-center gap-2">
          <label className="text-sm font-medium">Alpha (α):</label>
          <input
            type="range"
            min="0.1"
            max="0.5"
            step="0.05"
            value={alpha}
            onChange={(e) => setAlpha(parseFloat(e.target.value))}
            className="w-24"
          />
          <span className="text-sm font-mono w-16">{alpha.toFixed(2)}</span>
        </div>
        <div className="flex items-center gap-2">
          <label className="text-sm font-medium">Noise Level:</label>
          <input
            type="range"
            min="0"
            max="0.3"
            step="0.05"
            value={noiseLevel}
            onChange={(e) => setNoiseLevel(parseFloat(e.target.value))}
            className="w-24"
          />
          <span className="text-sm font-mono w-12">{noiseLevel.toFixed(2)}</span>
        </div>
      </div>

      {/* Enhanced Controls */}
      <div className="flex justify-center gap-2 mb-4">
        <button
          onClick={stepBackward}
          disabled={highlightIndex === 0 && currentM === selectedM && !showMatrix}
          className="flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
        >
          <SkipBack size={16} />
          Previous
        </button>
        <button
          onClick={togglePlay}
          className="flex items-center gap-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
        >
          {isPlaying ? <Pause size={16} /> : <Play size={16} />}
          {isPlaying ? 'Pause' : 'Play'}
        </button>
        <button
          onClick={stepForward}
          disabled={showMatrix}
          className="flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
        >
          Next
          <SkipForward size={16} />
        </button>
        <button
          onClick={reset}
          className="flex items-center gap-1 px-3 py-2 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
        >
          <RotateCcw size={16} />
          Reset
        </button>
      </div>

      {/* Progress Indicator */}
      <div className="mb-6 text-center">
        <div className="text-sm text-gray-600 mb-2">
          {showMatrix ? "Showing Results" : `Analyzing m=${currentM}, Pattern ${highlightIndex + 1} of ${N_analysis - currentM + 1}`}
        </div>
      </div>

      {!showMatrix ? (
        <>
          <div className="mb-6 p-4 bg-blue-50 rounded text-center">
            <h3 className="font-bold text-lg mb-2">
              Analyzing m={currentM} patterns (Pattern {highlightIndex + 1} of {N_analysis - currentM + 1})
            </h3>
            <p className="text-gray-700">
              {currentM === selectedM ? 
                `Examining ${selectedM}-point patterns from the analysis window, searching for similar patterns across both signals.` :
                `Now looking at ${selectedM + 1}-point patterns to see how complexity changes with longer sequences.`
              }
            </p>
          </div>

          <div className="space-y-6">
            <SignalPlot 
              signal={noiseSignal} 
              title="Signal A: Random Fluctuations" 
              color="#ef4444"
              similarIndices={noiseSimilar}
            />
            <SignalPlot 
              signal={regularSignal} 
              title="Signal B: Periodic Oscillations (with noise)" 
              color="#3b82f6"
              similarIndices={regularSimilar}
            />
          </div>
        </>
      ) : (
        <>
          <div className="mb-6 p-4 bg-gray-100 rounded">
            <h3 className="text-lg font-bold mb-3 text-center">Approximate Entropy Formula</h3>
            <div className="text-center">
              <div className="text-lg font-mono mb-2">
                ApEn(m, α) = φ<sup>m</sup>(r) - φ<sup>m+1</sup>(r), where r = α × SD(signal)
              </div>
              <div className="text-sm font-mono mb-2">
                φ<sup>m</sup>(r) = (1/N) × Σ ln(C<sub>i</sub><sup>m</sup>(r))
              </div>
              <div className="text-xs font-mono text-gray-600 mb-2">
                C<sub>i</sub><sup>m</sup>(r) = (number of patterns j such that d[x(i), x(j)] ≤ r) / N
                <br />
                where N = total possible patterns in signal, i and j are sampled from &#123;1, 2, ..., N&#125; with i ≠ j
                <br />
                <span className="text-orange-600">Pattern i = current pattern (orange)</span> • <span className="text-green-600">Pattern j = compared patterns (green)</span>
              </div>
              <div className="text-xs font-mono text-purple-600 mb-2">
                d[x(i), x(j)] = max|x(i+k) - x(j+k)| for k = 0, 1, ..., m-1 (Chebyshev distance)
              </div>
              <div className="text-xs bg-yellow-50 p-2 rounded border border-yellow-200">
                <strong>Note:</strong> x(j) represents all possible m-length patterns in the signal. Green highlights show only the matching patterns (where d[x(i), x(j)] ≤ r). 
                The C equation compares distances between all pattern pairs to count matches.
                <br />
                <strong>Educational Setup:</strong> The analysis window (first 10 samples) is selected for demonstration purposes. 
                In practice, all patterns across the entire signal would be analyzed for comprehensive ApEn calculation.
              </div>
            </div>
          </div>

          <div className="mb-8">
            <h3 className="text-xl font-bold mb-6 text-center">Pattern Repetition Counts</h3>
            <div className="text-sm text-center mb-6 text-gray-600">
              Pattern repetition analysis: How many times does each pattern repeat across the signal recordings?
            </div>
            
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
              <div>
                <h4 className="text-lg font-medium mb-4 text-center text-blue-800">Signal B: Periodic Oscillations</h4>
                <div className="mb-4">
                  <h4 className="text-sm font-medium mb-2 text-center">m={selectedM} Pattern Counts</h4>
                  <div className="bg-white border rounded overflow-hidden">
                    <table className="w-full text-sm">
                      <thead className="bg-gray-50">
                        <tr>
                          <th className="px-3 py-2 text-left border-r">Pattern</th>
                          <th className="px-3 py-2 text-center border-r">Count</th>
                          <th className="px-3 py-2 text-center">C<sub>i</sub><sup>{selectedM}</sup>(r)</th>
                        </tr>
                      </thead>
                      <tbody>
                        {regularCountsM.map((count, index) => {
                          const totalPossiblePatterns = N_display - selectedM + 1;
                          const cValue = count / totalPossiblePatterns;
                          return (
                            <tr key={index} className="border-t">
                              <td className="px-3 py-2 border-r font-mono">Pattern {index + 1}</td>
                              <td className="px-3 py-2 text-center font-bold border-r text-blue-700">
                                {count}
                              </td>
                              <td className="px-3 py-2 text-center font-mono text-gray-600">
                                {cValue.toFixed(3)}
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
                <div className="mb-4">
                  <h4 className="text-sm font-medium mb-2 text-center">m={selectedM + 1} Pattern Counts</h4>
                  <div className="bg-white border rounded overflow-hidden">
                    <table className="w-full text-sm">
                      <thead className="bg-gray-50">
                        <tr>
                          <th className="px-3 py-2 text-left border-r">Pattern</th>
                          <th className="px-3 py-2 text-center border-r">Count</th>
                          <th className="px-3 py-2 text-center">C<sub>i</sub><sup>{selectedM + 1}</sup>(r)</th>
                        </tr>
                      </thead>
                      <tbody>
                        {regularCountsM1.map((count, index) => {
                          const totalPossiblePatterns = N_display - (selectedM + 1) + 1;
                          const cValue = count / totalPossiblePatterns;
                          return (
                            <tr key={index} className="border-t">
                              <td className="px-3 py-2 border-r font-mono">Pattern {index + 1}</td>
                              <td className="px-3 py-2 text-center font-bold border-r text-blue-700">
                                {count}
                              </td>
                              <td className="px-3 py-2 text-center font-mono text-gray-600">
                                {cValue.toFixed(3)}
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
              
              <div>
                <h4 className="text-lg font-medium mb-4 text-center text-red-800">Signal A: Random Fluctuations</h4>
                <div className="mb-4">
                  <h4 className="text-sm font-medium mb-2 text-center">m={selectedM} Pattern Counts</h4>
                  <div className="bg-white border rounded overflow-hidden">
                    <table className="w-full text-sm">
                      <thead className="bg-gray-50">
                        <tr>
                          <th className="px-3 py-2 text-left border-r">Pattern</th>
                          <th className="px-3 py-2 text-center border-r">Count</th>
                          <th className="px-3 py-2 text-center">C<sub>i</sub><sup>{selectedM}</sup>(r)</th>
                        </tr>
                      </thead>
                      <tbody>
                        {noiseCountsM.map((count, index) => {
                          const totalPossiblePatterns = N_display - selectedM + 1;
                          const cValue = count / totalPossiblePatterns;
                          return (
                            <tr key={index} className="border-t">
                              <td className="px-3 py-2 border-r font-mono">Pattern {index + 1}</td>
                              <td className="px-3 py-2 text-center font-bold border-r text-red-700">
                                {count}
                              </td>
                              <td className="px-3 py-2 text-center font-mono text-gray-600">
                                {cValue.toFixed(3)}
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
                <div className="mb-4">
                  <h4 className="text-sm font-medium mb-2 text-center">m={selectedM + 1} Pattern Counts</h4>
                  <div className="bg-white border rounded overflow-hidden">
                    <table className="w-full text-sm">
                      <thead className="bg-gray-50">
                        <tr>
                          <th className="px-3 py-2 text-left border-r">Pattern</th>
                          <th className="px-3 py-2 text-center border-r">Count</th>
                          <th className="px-3 py-2 text-center">C<sub>i</sub><sup>{selectedM + 1}</sup>(r)</th>
                        </tr>
                      </thead>
                      <tbody>
                        {noiseCountsM1.map((count, index) => {
                          const totalPossiblePatterns = N_display - (selectedM + 1) + 1;
                          const cValue = count / totalPossiblePatterns;
                          return (
                            <tr key={index} className="border-t">
                              <td className="px-3 py-2 border-r font-mono">Pattern {index + 1}</td>
                              <td className="px-3 py-2 text-center font-bold border-r text-red-700">
                                {count}
                              </td>
                              <td className="px-3 py-2 text-center font-mono text-gray-600">
                                {cValue.toFixed(3)}
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-yellow-50 border-l-4 border-yellow-400 p-6 mb-8">
            <h3 className="text-lg font-bold mb-4 text-center">Approximate Entropy Results</h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="text-center">
                <h4 className="font-medium text-blue-800 mb-2">Signal B: Periodic Oscillations</h4>
                <div className="bg-white p-4 rounded">
                  <div>φ({selectedM}) = {regularPhiM.toFixed(4)}</div>
                  <div>φ({selectedM + 1}) = {regularPhiM1.toFixed(4)}</div>
                  <div className="text-lg font-bold mt-2 text-blue-800">
                    ApEn = {regularApEn.toFixed(4)}
                  </div>
                </div>
              </div>
              
              <div className="text-center">
                <h4 className="font-medium text-red-800 mb-2">Signal A: Random Fluctuations</h4>
                <div className="bg-white p-4 rounded">
                  <div>φ({selectedM}) = {noisePhiM.toFixed(4)}</div>
                  <div>φ({selectedM + 1}) = {noisePhiM1.toFixed(4)}</div>
                  <div className="text-lg font-bold mt-2 text-red-800">
                    ApEn = {noiseApEn.toFixed(4)}
                  </div>
                </div>
              </div>
            </div>
            
            <div className="text-center mt-4 text-sm text-gray-700">
              <strong>Key Insight:</strong> If a signal is regular across a specific length, then the count of m-length and (m+1)-length patterns should be approximately equal. 
              If the signal is irregular, there will be more m-length matches than (m+1)-length matches simply because of chances. 
              Hence, φ<sup>m</sup>(r) - φ<sup>m+1</sup>(r) will be higher for irregular systems (where the first value exceeds the second), 
              while both φ values should be approximately equal for signals showing regularities.
            </div>
          </div>
        </>
      )}

      <div className="mt-4 text-xs text-center text-gray-500">
        α = {alpha} • Signal A: r = {noiseR.toFixed(3)} • Signal B: r = {regularR.toFixed(3)} • Noise level = {noiseLevel} • Analysis window: first {N_analysis} samples • Displaying {N_display} samples
      </div>
    </div>
  );
};

export default ApproximateEntropyAnimation;
