<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualization of Approximate Entropy Analysis</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const ApproximateEntropyAnimation = () => {
          const [isPlaying, setIsPlaying] = useState(false);
          const [selectedM, setSelectedM] = useState(2);
          const [currentM, setCurrentM] = useState(2);
          const [highlightIndex, setHighlightIndex] = useState(0);
          const [showMatrix, setShowMatrix] = useState(false);
          const [alpha, setAlpha] = useState(0.2);
          const [noiseLevel, setNoiseLevel] = useState(0.1);
          const intervalRef = useRef(null);

          // Generate the two signals
          const generateRegularSignal = () => {
            const signal = [];
            const period = 20;
            for (let i = 0; i < 150; i++) {
              const phase = (i % period) / period;
              let value;
              if (phase < 0.5) {
                value = -0.5 + 2 * phase;
              } else {
                value = 0.5 - 2 * (phase - 0.5);
              }
              value += (Math.random() - 0.5) * 2 * noiseLevel;
              signal.push(value);
            }
            return signal;
          };

          const generateNoiseSignal = () => {
            const signal = [];
            for (let i = 0; i < 150; i++) {
              signal.push((Math.random() - 0.5));
            }
            return signal;
          };

          const [regularSignal, setRegularSignal] = useState(generateRegularSignal());
          const [noiseSignal, setNoiseSignal] = useState(generateNoiseSignal());

          useEffect(() => {
            setRegularSignal(generateRegularSignal());
            setNoiseSignal(generateNoiseSignal());
          }, [noiseLevel]);

          // Calculate standard deviation of the signal
          const calculateSD = (signal) => {
            const mean = signal.reduce((sum, val) => sum + val, 0) / signal.length;
            const variance = signal.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / signal.length;
            return Math.sqrt(variance);
          };

          const N_analysis = 10;
          const N_display = 50;

          const regularSD = calculateSD(regularSignal.slice(0, N_display));
          const noiseSD = calculateSD(noiseSignal.slice(0, N_display));
          const regularR = alpha * regularSD;
          const noiseR = alpha * noiseSD;

          const findSimilarPatterns = (signal, startIndex, m, r) => {
            if (startIndex >= N_analysis - m + 1) return [];
            
            const currentPattern = signal.slice(startIndex, startIndex + m);
            const similarPatterns = [];
            
            for (let i = 0; i <= N_display - m; i++) {
              const comparePattern = signal.slice(i, i + m);
              
              let chebyshevDistance = 0;
              for (let j = 0; j < m; j++) {
                const diff = Math.abs(currentPattern[j] - comparePattern[j]);
                chebyshevDistance = Math.max(chebyshevDistance, diff);
              }
              
              if (chebyshevDistance <= r) {
                similarPatterns.push(i);
              }
            }
            return similarPatterns;
          };

          const createPatternCounts = (signal, m, r) => {
            const analysisPatterns = N_analysis - m + 1;
            const counts = [];
            
            for (let i = 0; i < analysisPatterns; i++) {
              const similarPatterns = findSimilarPatterns(signal, i, m, r);
              counts.push(similarPatterns.length);
            }
            return counts;
          };

          const computeApEn = (signal, m, r) => {
            const numPatterns = N_analysis - m + 1;
            const totalPossiblePatterns = N_display - m + 1;
            let phi = 0;
            
            for (let i = 0; i < numPatterns; i++) {
              const similarPatterns = findSimilarPatterns(signal, i, m, r);
              const C = similarPatterns.length / totalPossiblePatterns;
              if (C > 0) {
                phi += Math.log(C);
              }
            }
            
            return phi / numPatterns;
          };

          const regularSimilar = findSimilarPatterns(regularSignal, highlightIndex, currentM, regularR);
          const noiseSimilar = findSimilarPatterns(noiseSignal, highlightIndex, currentM, noiseR);

          const regularPhiM = computeApEn(regularSignal, selectedM, regularR);
          const regularPhiM1 = computeApEn(regularSignal, selectedM + 1, regularR);
          const regularApEn = regularPhiM - regularPhiM1;

          const noisePhiM = computeApEn(noiseSignal, selectedM, noiseR);
          const noisePhiM1 = computeApEn(noiseSignal, selectedM + 1, noiseR);
          const noiseApEn = noisePhiM - noisePhiM1;

          const regularCountsM = createPatternCounts(regularSignal, selectedM, regularR);
          const noiseCountsM = createPatternCounts(noiseSignal, selectedM, noiseR);
          const regularCountsM1 = createPatternCounts(regularSignal, selectedM + 1, regularR);
          const noiseCountsM1 = createPatternCounts(noiseSignal, selectedM + 1, noiseR);

          useEffect(() => {
            if (isPlaying) {
              intervalRef.current = setInterval(() => {
                setHighlightIndex(prev => {
                  const next = prev + 1;
                  const maxIndex = N_analysis - currentM;
                  if (next >= maxIndex) {
                    if (currentM === selectedM) {
                      setCurrentM(selectedM + 1);
                      return 0;
                    } else {
                      setShowMatrix(true);
                      setIsPlaying(false);
                      return 0;
                    }
                  }
                  return next;
                });
              }, 1000);
            } else {
              clearInterval(intervalRef.current);
            }
            return () => clearInterval(intervalRef.current);
          }, [isPlaying, currentM, selectedM]);

          const togglePlay = () => setIsPlaying(!isPlaying);
          const reset = () => {
            setHighlightIndex(0);
            setCurrentM(selectedM);
            setShowMatrix(false);
            setIsPlaying(false);
          };

          const stepForward = () => {
            if (showMatrix) return;
            
            const maxIndex = N_analysis - currentM;
            if (highlightIndex + 1 >= maxIndex) {
              if (currentM === selectedM) {
                setCurrentM(selectedM + 1);
                setHighlightIndex(0);
              } else {
                setShowMatrix(true);
              }
            } else {
              setHighlightIndex(prev => prev + 1);
            }
          };

          const stepBackward = () => {
            if (showMatrix) {
              setShowMatrix(false);
              setCurrentM(selectedM + 1);
              setHighlightIndex(N_analysis - (selectedM + 1) - 1);
              return;
            }
            
            if (highlightIndex > 0) {
              setHighlightIndex(prev => prev - 1);
            } else if (currentM === selectedM + 1) {
              setCurrentM(selectedM);
              setHighlightIndex(N_analysis - selectedM - 1);
            }
          };

          const SignalPlot = ({ signal, title, color, similarIndices }) => (
            React.createElement('div', { className: 'mb-4' },
              React.createElement('h4', { className: 'text-sm font-medium mb-2' }, title),
              React.createElement('div', { className: 'relative h-24 bg-gray-50 border rounded' },
                React.createElement('svg', { width: '100%', height: '100%', viewBox: '0 0 300 96' },
                  React.createElement('polyline', {
                    points: signal.slice(0, N_display).map((val, i) => `${i * 6},${48 - val * 70}`).join(' '),
                    fill: 'none',
                    stroke: color,
                    strokeWidth: '1.5'
                  }),
                  
                  React.createElement('rect', {
                    x: '0', y: '5', width: N_analysis * 6, height: '86',
                    fill: 'rgba(0,100,255,0.1)', stroke: 'rgba(0,100,255,0.3)',
                    strokeWidth: '1', strokeDasharray: '3,3'
                  }),
                  React.createElement('text', {
                    x: N_analysis * 3, y: 20, textAnchor: 'middle', fontSize: '9',
                    fill: '#0066ff', fontWeight: 'bold'
                  }, 'Analysis Window'),
                  
                  !showMatrix && similarIndices.filter(idx => idx !== highlightIndex).map(idx =>
                    React.createElement('g', { key: idx },
                      React.createElement('polyline', {
                        points: signal.slice(idx, idx + currentM)
                          .map((val, i) => `${(idx + i) * 6},${48 - val * 70}`).join(' '),
                        fill: 'none', stroke: '#10b981', strokeWidth: '4', opacity: '0.8'
                      }),
                      ...signal.slice(idx, idx + currentM).map((val, i) =>
                        React.createElement('circle', {
                          key: i, cx: (idx + i) * 6, cy: 48 - val * 70, r: '2.5',
                          fill: '#10b981', stroke: 'white', strokeWidth: '1'
                        })
                      )
                    )
                  ),
                  
                  !showMatrix && highlightIndex < N_analysis - currentM + 1 && React.createElement('g', {},
                    React.createElement('polyline', {
                      points: signal.slice(highlightIndex, highlightIndex + currentM)
                        .map((val, i) => `${(highlightIndex + i) * 6},${48 - val * 70}`).join(' '),
                      fill: 'none', stroke: '#ff6b35', strokeWidth: '4'
                    }),
                    
                    ...signal.slice(highlightIndex, highlightIndex + currentM).map((val, i) =>
                      React.createElement('circle', {
                        key: i, cx: (highlightIndex + i) * 6, cy: 48 - val * 70, r: '4',
                        fill: '#ff6b35', stroke: 'white', strokeWidth: '1'
                      })
                    ),
                    
                    React.createElement('text', {
                      x: (highlightIndex + (currentM-1)/2) * 6, y: 35, textAnchor: 'middle',
                      fontSize: '11', fill: '#ff6b35', fontWeight: 'bold'
                    }, 'Current')
                  ),
                  
                  React.createElement('line', {
                    x1: '0', y1: '48', x2: '300', y2: '48',
                    stroke: '#ddd', strokeWidth: '1'
                  })
                )
              ),
              !showMatrix && React.createElement('div', { className: 'text-xs mt-1 text-center' },
                React.createElement('span', { className: 'text-orange-600 font-medium' }, 
                  `Pattern ${highlightIndex + 1}: Current pattern from analysis window`
                ),
                similarIndices.length > 1 && React.createElement('span', { className: 'ml-4 text-green-600 font-medium' },
                  `Similar patterns to Pattern ${highlightIndex + 1}: ${similarIndices.length - 1} matches found`
                )
              )
            )
          );

          return React.createElement('div', { className: 'max-w-6xl mx-auto p-6 bg-white' },
            React.createElement('h2', { className: 'text-2xl font-bold mb-6 text-center' },
              'Visualization of Approximate Entropy Analysis'
            ),

            React.createElement('div', { className: 'mb-8 p-6 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border-l-4 border-blue-500' },
              React.createElement('h3', { className: 'text-xl font-bold mb-4 text-gray-800' },
                'How do you measure the regularity of a signal when you don\'t know what function it follows?'
              ),
              
              React.createElement('div', { className: 'space-y-4 text-gray-700' },
                React.createElement('p', { className: 'text-base leading-relaxed' },
                  'Consider analyzing ', React.createElement('strong', {}, 'sensor data from a complex dynamical system'),
                  ' - perhaps temperature fluctuations in a chemical reactor, stock market prices, seismic activity recordings, or electrophysiological signals. These signals appear intricate and unpredictable, yet some may contain underlying regularities while others are purely chaotic.'
                ),
                
                React.createElement('p', { className: 'text-base leading-relaxed' },
                  React.createElement('strong', {}, 'Approximate Entropy (ApEn)'),
                  ' addresses this challenge by quantifying pattern regularity without requiring knowledge of the underlying mathematical function the system can be described with. Even when we cannot understand the specific mechanisms generating the signal, we can assess whether there is some inherent regularity or randomness - something that can be informative about the complexity of the system.'
                ),

                React.createElement('div', { className: 'bg-white p-4 rounded border-l-4 border-purple-400' },
                  React.createElement('h4', { className: 'font-semibold mb-2 text-purple-800' }, 'What you\'ll explore:'),
                  React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4 text-sm' },
                    React.createElement('div', {},
                      React.createElement('p', {}, React.createElement('strong', {}, 'Signal A (Red):'), ' Random fluctuations - irregular, unpredictable patterns'),
                      React.createElement('p', {}, React.createElement('strong', {}, 'Signal B (Blue):'), ' Periodic oscillations - regular, repeating patterns')
                    ),
                    React.createElement('div', {},
                      React.createElement('p', {}, React.createElement('strong', {}, 'Pattern Length:'), ` Number of consecutive points in each pattern (m = ${selectedM})`),
                      React.createElement('p', {}, React.createElement('strong', {}, 'Alpha (α):'), ' Scaling factor for adaptive tolerance (r = α × standard deviation (SD))'),
                      React.createElement('p', {}, React.createElement('strong', {}, 'Noise Level:'), ' Add noise to the regular recording')
                    )
                  )
                ),

                React.createElement('div', { className: 'bg-white p-4 rounded border-l-4 border-green-400' },
                  React.createElement('h4', { className: 'font-semibold mb-2 text-green-800' }, 'Interactive Exploration:'),
                  React.createElement('p', { className: 'text-sm text-gray-700' },
                    'Try to figure out how different parameters affect the analysis! Does the analysis still work properly when collected data are noisy? Does it help to increase α or m to combat noise? Can you explain why?'
                  )
                )
              )
            ),

            React.createElement('div', { className: 'flex justify-center gap-6 mb-4 p-4 bg-gray-50 rounded' },
              React.createElement('div', { className: 'flex items-center gap-2' },
                React.createElement('label', { className: 'text-sm font-medium' }, 'Pattern Length:'),
                React.createElement('input', {
                  type: 'range', min: '2', max: '5', step: '1', value: selectedM,
                  onChange: (e) => {
                    const newM = parseInt(e.target.value);
                    setSelectedM(newM);
                    setCurrentM(newM);
                    setShowMatrix(false);
                    setHighlightIndex(0);
                  },
                  className: 'w-24'
                }),
                React.createElement('span', { className: 'text-sm font-mono w-12' }, `m = ${selectedM}`)
              ),
              React.createElement('div', { className: 'flex items-center gap-2' },
                React.createElement('label', { className: 'text-sm font-medium' }, 'Alpha (α):'),
                React.createElement('input', {
                  type: 'range', min: '0.1', max: '0.5', step: '0.05', value: alpha,
                  onChange: (e) => setAlpha(parseFloat(e.target.value)),
                  className: 'w-24'
                }),
                React.createElement('span', { className: 'text-sm font-mono w-16' }, alpha.toFixed(2))
              ),
              React.createElement('div', { className: 'flex items-center gap-2' },
                React.createElement('label', { className: 'text-sm font-medium' }, 'Noise Level:'),
                React.createElement('input', {
                  type: 'range', min: '0', max: '0.3', step: '0.05', value: noiseLevel,
                  onChange: (e) => setNoiseLevel(parseFloat(e.target.value)),
                  className: 'w-24'
                }),
                React.createElement('span', { className: 'text-sm font-mono w-12' }, noiseLevel.toFixed(2))
              )
            ),

            React.createElement('div', { className: 'flex justify-center gap-2 mb-4' },
              React.createElement('button', {
                onClick: stepBackward,
                disabled: highlightIndex === 0 && currentM === selectedM && !showMatrix,
                className: 'flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm'
              }, '← Previous'),
              React.createElement('button', {
                onClick: togglePlay,
                className: 'flex items-center gap-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm'
              }, isPlaying ? 'Pause' : 'Play'),
              React.createElement('button', {
                onClick: stepForward,
                disabled: showMatrix,
                className: 'flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm'
              }, 'Next →'),
              React.createElement('button', {
                onClick: reset,
                className: 'flex items-center gap-1 px-3 py-2 bg-red-500 text-white rounded hover:bg-red-600 text-sm'
              }, 'Reset')
            ),

            React.createElement('div', { className: 'mb-6 text-center' },
              React.createElement('div', { className: 'text-sm text-gray-600 mb-2' },
                showMatrix ? "Showing Results" : `Analyzing m=${currentM}, Pattern ${highlightIndex + 1} of ${N_analysis - currentM + 1}`
              )
            ),

            !showMatrix ? [
              React.createElement('div', { key: 'analysis', className: 'mb-6 p-4 bg-blue-50 rounded text-center' },
                React.createElement('h3', { className: 'font-bold text-lg mb-2' },
                  `Analyzing m=${currentM} patterns (Pattern ${highlightIndex + 1} of ${N_analysis - currentM + 1})`
                ),
                React.createElement('p', { className: 'text-gray-700' },
                  currentM === selectedM ? 
                    `Examining ${selectedM}-point patterns from the analysis window, searching for similar patterns across both signals.` :
                    `Now looking at ${selectedM + 1}-point patterns to see how complexity changes with longer sequences.`
                )
              ),

              React.createElement('div', { key: 'plots', className: 'space-y-6' },
                React.createElement(SignalPlot, {
                  signal: noiseSignal,
                  title: 'Signal A: Random Fluctuations',
                  color: '#ef4444',
                  similarIndices: noiseSimilar
                }),
                React.createElement(SignalPlot, {
                  signal: regularSignal,
                  title: 'Signal B: Periodic Oscillations (with noise)',
                  color: '#3b82f6',
                  similarIndices: regularSimilar
                })
              )
            ] : [
              React.createElement('div', { key: 'formula', className: 'mb-6 p-4 bg-gray-100 rounded' },
                React.createElement('h3', { className: 'text-lg font-bold mb-3 text-center' }, 'Approximate Entropy Formula'),
                React.createElement('div', { className: 'text-center' },
                  React.createElement('div', { className: 'text-lg font-mono mb-2' },
                    'ApEn(m, α) = φᵐ(r) - φᵐ⁺¹(r), where r = α × SD(signal)'
                  ),
                  React.createElement('div', { className: 'text-sm font-mono mb-2' },
                    'φᵐ(r) = (1/N) × Σ ln(Cᵢᵐ(r))'
                  ),
                  React.createElement('div', { className: 'text-xs font-mono text-gray-600 mb-2' },
                    'Cᵢᵐ(r) = (number of patterns j such that d[x(i), x(j)] ≤ r) / N',
                    React.createElement('br'),
                    'where N = total possible patterns in signal, i and j are sampled from (1, 2, ..., N) with i ≠ j',
                    React.createElement('br'),
                    React.createElement('span', { className: 'text-orange-600' }, 'Pattern i = current pattern (orange)'),
                    ' • ',
                    React.createElement('span', { className: 'text-green-600' }, 'Pattern j = compared patterns (green)')
                  ),
                  React.createElement('div', { className: 'text-xs font-mono text-purple-600 mb-2' },
                    'd[x(i), x(j)] = max|x(i+k) - x(j+k)| for k = 0, 1, ..., m-1 (Chebyshev distance)'
                  ),
                  React.createElement('div', { className: 'text-xs bg-yellow-50 p-2 rounded border border-yellow-200' },
                    React.createElement('strong', {}, 'Note:'), ' x(j) represents all possible m-length patterns in the signal. Green highlights show only the matching patterns (where d[x(i), x(j)] ≤ r). The C equation compares distances between all pattern pairs to count matches.',
                    React.createElement('br'),
                    React.createElement('strong', {}, 'Educational Setup:'), ' The analysis window (first 10 samples) is selected for demonstration purposes. In practice, all patterns across the entire signal would be analyzed for comprehensive ApEn calculation.'
                  )
                )
              ),

              React.createElement('div', { key: 'results', className: 'bg-yellow-50 border-l-4 border-yellow-400 p-6 mb-8' },
                React.createElement('h3', { className: 'text-lg font-bold mb-4 text-center' }, 'Approximate Entropy Results'),
                
                React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-6' },
                  React.createElement('div', { className: 'text-center' },
                    React.createElement('h4', { className: 'font-medium text-blue-800 mb-2' }, 'Signal B: Periodic Oscillations'),
                    React.createElement('div', { className: 'bg-white p-4 rounded' },
                      React.createElement('div', {}, `φ(${selectedM}) = ${regularPhiM.toFixed(4)}`),
                      React.createElement('div', {}, `φ(${selectedM + 1}) = ${regularPhiM1.toFixed(4)}`),
                      React.createElement('div', { className: 'text-lg font-bold mt-2 text-blue-800' },
                        `ApEn = ${regularApEn.toFixed(4)}`
                      )
                    )
                  ),
                  
                  React.createElement('div', { className: 'text-center' },
                    React.createElement('h4', { className: 'font-medium text-red-800 mb-2' }, 'Signal A: Random Fluctuations'),
                    React.createElement('div', { className: 'bg-white p-4 rounded' },
                      React.createElement('div', {}, `φ(${selectedM}) = ${noisePhiM.toFixed(4)}`),
                      React.createElement('div', {}, `φ(${selectedM + 1}) = ${noisePhiM1.toFixed(4)}`),
                      React.createElement('div', { className: 'text-lg font-bold mt-2 text-red-800' },
                        `ApEn = ${noiseApEn.toFixed(4)}`
                      )
                    )
                  )
                ),
                
                React.createElement('div', { className: 'text-center mt-4 text-sm text-gray-700' },
                  React.createElement('strong', {}, 'Key Insight:'), ' If a signal is regular across a specific length, then the count of m-length and (m+1)-length patterns should be approximately equal. If the signal is irregular, there will be more m-length matches than (m+1)-length matches simply because of chances. Hence, φᵐ(r) - φᵐ⁺¹(r) will be higher for irregular systems, while both φ values should be approximately equal for signals showing regularities.'
                )
              )
            ],

            React.createElement('div', { className: 'mt-4 text-xs text-center text-gray-500' },
              `α = ${alpha} • Signal A: r = ${noiseR.toFixed(3)} • Signal B: r = ${regularR.toFixed(3)} • Noise level = ${noiseLevel} • Analysis window: first ${N_analysis} samples • Displaying ${N_display} samples`
            )
          );
        };

        ReactDOM.render(React.createElement(ApproximateEntropyAnimation), document.getElementById('root'));
    </script>
</body>
</html>
