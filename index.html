<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualization of Approximate Entropy Analysis</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #333;
        }
        h1 {
            text-align: center;
        }
        .intro-box {
            background: linear-gradient(to right, #e0e7ff, #ede9fe);
            padding: 24px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            margin-bottom: 20px;
        }
        .intro-box h2 {
            color: #1f2937;
            font-size: 1.25rem;
            margin-bottom: 16px;
        }
        .intro-box p {
            color: #374151;
            line-height: 1.6;
            margin-bottom: 16px;
        }
        .explore-box {
            background-color: white;
            padding: 16px;
            border-radius: 6px;
            border-left: 4px solid #8b5cf6;
            margin: 16px 0;
        }
        .explore-box h4 {
            color: #7c3aed;
            margin-bottom: 8px;
        }
        .explore-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            font-size: 0.875rem;
        }
        .explore-grid p {
            margin: 4px 0;
        }
        .interactive-box {
            background-color: white;
            padding: 16px;
            border-radius: 6px;
            border-left: 4px solid #10b981;
            margin-top: 16px;
        }
        .interactive-box h4 {
            color: #059669;
            margin-bottom: 8px;
        }
        .controls {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            font-weight: bold;
            font-size: 0.875rem;
        }
        input[type="range"] {
            width: 100px;
        }
        .value-display {
            font-family: monospace;
            width: 60px;
            font-size: 0.875rem;
        }
        .button-container {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 4px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover:not(:disabled) {
            background-color: #2563eb;
        }
        button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        #resetBtn {
            background-color: #ef4444;
        }
        #resetBtn:hover {
            background-color: #dc2626;
        }
        .signal-container {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
        }
        .signal-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.875rem;
        }
        canvas {
            border: 1px solid #ddd;
            width: 100%;
            max-width: 800px;
        }
        .tables-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        .count-table-container {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 12px;
            background-color: #f9f9f9;
        }
        .count-table-container h3 {
            margin-top: 0;
            text-align: center;
            font-size: 1rem;
        }
        .table-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: center;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        tr.highlight {
            background-color: #ffcc80;
        }
        .formula-box {
            background-color: #f3f4f6;
            padding: 24px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        .formula-box h3 {
            margin-bottom: 16px;
        }
        .formula {
            font-family: 'Courier New', monospace;
            margin: 8px 0;
        }
        .formula-main {
            font-size: 1.125rem;
            margin-bottom: 16px;
        }
        .formula-sub {
            font-size: 0.875rem;
            margin: 4px 0;
        }
        .formula-detail {
            font-size: 0.75rem;
            color: #4b5563;
            margin: 4px 0;
        }
        .formula-note {
            background-color: #fef3c7;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #fbbf24;
            margin-top: 16px;
            font-size: 0.75rem;
            text-align: left;
        }
        .results-box {
            background-color: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 24px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-top: 20px;
        }
        .result-item {
            text-align: center;
            background-color: white;
            padding: 16px;
            border-radius: 4px;
        }
        .result-item h4 {
            margin-bottom: 12px;
        }
        .result-value {
            font-size: 1.25rem;
            font-weight: bold;
            margin-top: 8px;
        }
        .blue-text { color: #3b82f6; }
        .red-text { color: #ef4444; }
        .status {
            text-align: center;
            font-size: 14px;
            margin: 16px 0;
            color: #666;
        }
        .key-insight {
            text-align: center;
            margin-top: 16px;
            font-size: 0.875rem;
            color: #374151;
        }
        .info-text {
            text-align: center;
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 16px;
        }
        @media (max-width: 768px) {
            .tables-container, .explore-grid, .results-grid {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Visualization of Approximate Entropy Analysis</h1>
        
        <div class="intro-box">
            <h2>How do you measure the regularity of a signal when you don't know what function it follows?</h2>
            
            <p>Consider analyzing <strong>sensor data from a complex dynamical system</strong> - perhaps temperature fluctuations in a chemical reactor, stock market prices, seismic activity recordings, or electrophysiological signals. These signals appear intricate and unpredictable, yet some may contain underlying regularities while others are purely chaotic.</p>
            
            <p><strong>Approximate Entropy (ApEn)</strong> addresses this challenge by quantifying pattern regularity without requiring knowledge of the underlying mathematical function the system can be described with. Even when we cannot understand the specific mechanisms generating the signal, we can assess whether there is some inherent regularity or randomness - something that can be informative about the complexity of the system.</p>
            
            <div class="explore-box">
                <h4>What you'll explore:</h4>
                <div class="explore-grid">
                    <div>
                        <p><strong>Signal A (Red):</strong> Random fluctuations - irregular, unpredictable patterns. You can press reset to generate another random signal</p>
                        <p><strong>Signal B (Blue):</strong> Periodic oscillations - regular, repeating patterns</p>
                    </div>
                    <div>
                        <p><strong>Pattern Length:</strong> Number of consecutive points in each pattern</p>
                        <p><strong>Alpha (α):</strong> Scaling factor for adaptive tolerance (r = α × standard deviation (SD))</p>
                        <p><strong>Noise Level:</strong> Add noise to the regular recording</p>
                        <p><strong>Analysis Window:</strong> The first 10 samples highlighted for visualization - helps you see the pattern matching process step by step (the actual ApEn calculation uses all patterns)</p>
                    </div>
                </div>
            </div>
            
            <div class="interactive-box">
                <h4>Interactive Exploration:</h4>
                <p style="font-size: 0.875rem; color: #374151;">Try to figure out how different parameters affect the analysis! Does the analysis still work properly when collected data are noisy? Does it help to increase α or m to combat noise, or does it matter if there's enough data? Can you explain why?</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Pattern Length:</label>
                <input type="range" id="mSlider" min="2" max="5" value="2">
                <span class="value-display">m = <span id="mValue">2</span></span>
            </div>
            <div class="control-group">
                <label>Alpha (α):</label>
                <input type="range" id="alphaSlider" min="0.1" max="0.5" step="0.05" value="0.2">
                <span class="value-display" id="alphaValue">0.20</span>
            </div>
            <div class="control-group">
                <label>Noise Level:</label>
                <input type="range" id="noiseSlider" min="0" max="0.3" step="0.05" value="0.1">
                <span class="value-display" id="noiseValue">0.10</span>
            </div>
            <div class="control-group">
                <label>Signal Length:</label>
                <input type="range" id="displaySlider" min="50" max="250" step="50" value="50">
                <span class="value-display" id="displayValue">50</span>
            </div>
        </div>
        
        <div class="button-container">
            <button id="prevBtn">← Previous</button>
            <button id="playBtn">Play</button>
            <button id="nextBtn">Next →</button>
            <button id="resetBtn">Reset</button>
        </div>
        
        <div class="status" id="status">Analyzing m=2, Pattern 1 of 9</div>
        
        <div id="analysisInfo" class="status" style="background-color: #dbeafe; padding: 16px; border-radius: 4px; margin-bottom: 20px;">
            <strong>Analyzing m=<span id="currentMInfo">2</span> patterns (Pattern <span id="currentPatternInfo">1</span> of <span id="totalPatternsInfo">9</span>)</strong><br>
            <span id="analysisDescription">Examining 2-point patterns from the analysis window, searching for similar patterns across both signals.</span>
        </div>
        
        <div class="signal-container">
            <div class="signal-title">Signal A: Random Fluctuations</div>
            <canvas id="signalA" width="800" height="200"></canvas>
            <div id="signalAInfo" style="text-align: center; font-size: 0.75rem; margin-top: 4px;">
                <span style="color: #ff8a65; font-weight: bold;">Pattern 1: Current pattern from analysis window</span>
                <span id="signalAMatches" style="color: #66bb6a; margin-left: 16px; font-weight: bold;"></span>
            </div>
        </div>
        
        <div class="signal-container">
            <div class="signal-title">Signal B: Periodic Oscillations (with noise)</div>
            <canvas id="signalB" width="800" height="200"></canvas>
            <div id="signalBInfo" style="text-align: center; font-size: 0.75rem; margin-top: 4px;">
                <span style="color: #ff8a65; font-weight: bold;">Pattern 1: Current pattern from analysis window</span>
                <span id="signalBMatches" style="color: #66bb6a; margin-left: 16px; font-weight: bold;"></span>
            </div>
        </div>
        
        <div id="formulaSection" style="display: none;">
            <div class="formula-box">
                <h3>Approximate Entropy Formula</h3>
                <div class="formula formula-main">ApEn(m, α) = φᵐ(r) - φᵐ⁺¹(r), where r = α × SD(signal)</div>
                <div class="formula formula-sub">φᵐ(r) = (1/N) × Σ ln(Cᵢᵐ(r))</div>
                <div class="formula formula-detail">
                    Cᵢᵐ(r) = (number of patterns j such that d[x(i), x(j)] ≤ r) / N<br>
                    where N = total possible patterns in signal, i and j are sampled from (1, 2, ..., N)<br>
                    <span style="color: #ff8a65;">Pattern i = current pattern (orange)</span> • 
                    <span style="color: #66bb6a;">Pattern j = compared patterns (green)</span>
                </div>
                <div class="formula formula-detail" style="color: #7c3aed;">
                    d[x(i), x(j)] = max|x(i+k) - x(j+k)| for k = 0, 1, ..., m-1 (Chebyshev distance)
                </div>
                <div class="formula-note">
                    <strong>Chebyshev distance:</strong> This measures the maximum difference between corresponding values in two patterns. For example, when comparing pattern [1, 2] with pattern [1, 4], the Chebyshev distance is 2 (the difference between 2 and 4). When comparing identical patterns like [1, 2] with [1, 2], the distance is 0.<br><br>
                    <strong>Note:</strong> x(j) represents all possible m-length patterns in the signal. Green highlights show only the matching patterns (where d[x(i), x(j)] ≤ r). The C equation compares distances between all pattern pairs to count matches.
                </div>
            </div>
            
            <p style="text-align: center; margin: 16px 0; font-size: 14px; color: #374151;">
                <strong>Note:</strong> The ApEn for both signals was computed with all patterns, not only those from the analysis window.
            </p>
            
            <div class="results-box">
                <h3 style="text-align: center; margin-bottom: 16px;">Approximate Entropy Results</h3>
                
                <div class="results-grid">
                    <div class="result-item">
                        <h4 class="red-text">Signal A: Random Fluctuations</h4>
                        <div>φ(<span class="m-value">2</span>) = <span id="phiA-m">0</span></div>
                        <div>φ(<span class="m-plus-value">3</span>) = <span id="phiA-m1">0</span></div>
                        <div class="result-value red-text">ApEn = <span id="apenA">0</span></div>
                    </div>
                    
                    <div class="result-item">
                        <h4 class="blue-text">Signal B: Periodic Oscillations</h4>
                        <div>φ(<span class="m-value">2</span>) = <span id="phiB-m">0</span></div>
                        <div>φ(<span class="m-plus-value">3</span>) = <span id="phiB-m1">0</span></div>
                        <div class="result-value blue-text">ApEn = <span id="apenB">0</span></div>
                    </div>
                </div>
                
                <div class="key-insight">
                    <strong>Key Insight:</strong> If a signal is regular across a specific length, then the count of m-length and (m+1)-length patterns should be approximately equal. If the signal is irregular, there will be more m-length matches than (m+1)-length matches simply because of chances. Hence, φᵐ(r) - φᵐ⁺¹(r) will be higher for irregular systems, while both φ values should be approximately equal for signals showing regularities.
                </div>
            </div>
        </div>
        
        <h3 style="text-align: center; margin-top: 40px;">Pattern Count Tables</h3>
        <div class="tables-container">
            <div class="count-table-container">
                <h3 class="red-text">Signal A: Random Fluctuations</h3>
                <div class="table-grid">
                    <div>
                        <h4 style="text-align: center; font-size: 0.875rem;">m = <span class="m-value">2</span></h4>
                        <table id="tableA-m">
                            <thead>
                                <tr>
                                    <th>Pattern</th>
                                    <th>Count</th>
                                    <th>Cᵢ(r)</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div>
                        <h4 style="text-align: center; font-size: 0.875rem;">m = <span class="m-plus-value">3</span></h4>
                        <table id="tableA-m1">
                            <thead>
                                <tr>
                                    <th>Pattern</th>
                                    <th>Count</th>
                                    <th>Cᵢ(r)</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div class="count-table-container">
                <h3 class="blue-text">Signal B: Periodic Oscillations</h3>
                <div class="table-grid">
                    <div>
                        <h4 style="text-align: center; font-size: 0.875rem;">m = <span class="m-value">2</span></h4>
                        <table id="tableB-m">
                            <thead>
                                <tr>
                                    <th>Pattern</th>
                                    <th>Count</th>
                                    <th>Cᵢ(r)</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div>
                        <h4 style="text-align: center; font-size: 0.875rem;">m = <span class="m-plus-value">3</span></h4>
                        <table id="tableB-m1">
                            <thead>
                                <tr>
                                    <th>Pattern</th>
                                    <th>Count</th>
                                    <th>Cᵢ(r)</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info-text">
            α = <span id="alphaInfo">0.2</span> • 
            Signal A: r = <span id="rAInfo">0</span> • 
            Signal B: r = <span id="rBInfo">0</span> • 
            Noise level = <span id="noiseInfo">0.1</span> • 
            Analysis window: first 10 samples (for visualization) • 
            Signal length: <span id="displayLengthInfo">50</span> samples
        </div>
    </div>

    <script>
        // Global variables
        let signalA = [];
        let signalB = [];
        let m = 2;
        let alpha = 0.2;
        let noiseLevel = 0.1;
        let currentM = 2;
        let highlightIndex = 0;
        let isPlaying = false;
        let showResults = false;
        let animationInterval = null;
        
        let N_ANALYSIS = 10;  // Fixed for visualization
        let N_DISPLAY = 50;
        
        // Generate signals
        function generateSignals() {
            // Only regenerate signal A on initialization or reset
            if (signalA.length === 0) {
                signalA = [];
                // Generate random signal
                for (let i = 0; i < 300; i++) {
                    signalA.push(Math.random() - 0.5);
                }
            }
            
            // Always regenerate signal B with current noise level
            signalB = [];
            const period = 20;
            for (let i = 0; i < 300; i++) {
                const phase = (i % period) / period;
                let value;
                if (phase < 0.5) {
                    value = -0.5 + 2 * phase;
                } else {
                    value = 0.5 - 2 * (phase - 0.5);
                }
                value += (Math.random() - 0.5) * 2 * noiseLevel;
                signalB.push(value);
            }
        }
        
        // Calculate standard deviation
        function calculateSD(signal) {
            const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
            const variance = signal.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / signal.length;
            return Math.sqrt(variance);
        }
        
        // Find similar patterns
        function findSimilarPatterns(signal, startIndex, m, r) {
            if (startIndex >= N_ANALYSIS - m + 1) return [];
            
            const currentPattern = signal.slice(startIndex, startIndex + m);
            const similarPatterns = [];
            
            for (let i = 0; i <= N_DISPLAY - m; i++) {
                const comparePattern = signal.slice(i, i + m);
                
                let maxDiff = 0;
                for (let j = 0; j < m; j++) {
                    const diff = Math.abs(currentPattern[j] - comparePattern[j]);
                    maxDiff = Math.max(maxDiff, diff);
                }
                
                if (maxDiff <= r) {
                    similarPatterns.push(i);
                }
            }
            return similarPatterns;
        }
        
        // Create pattern counts
        function createPatternCounts(signal, m, r) {
            const counts = [];
            const numPatterns = N_ANALYSIS - m + 1;
            const totalPatterns = N_DISPLAY - m + 1;
            
            for (let i = 0; i < numPatterns; i++) {
                const similar = findSimilarPatterns(signal, i, m, r);
                counts.push({
                    count: similar.length,
                    C: similar.length / totalPatterns
                });
            }
            return counts;
        }
        
        // Compute ApEn using all patterns in the signal
        function computeApEn(signal, m, r) {
            const numPatterns = N_DISPLAY - m + 1;  // Use all patterns in the signal
            let phi = 0;
            
            for (let i = 0; i < numPatterns; i++) {
                const similar = findSimilarPatternsForApEn(signal, i, m, r);
                const C = similar.length / numPatterns;
                if (C > 0) {
                    phi += Math.log(C);
                }
            }
            
            return phi / numPatterns;
        }
        
        // Find similar patterns for ApEn calculation (uses all patterns)
        function findSimilarPatternsForApEn(signal, startIndex, m, r) {
            const currentPattern = signal.slice(startIndex, startIndex + m);
            const similarPatterns = [];
            
            for (let i = 0; i <= N_DISPLAY - m; i++) {
                const comparePattern = signal.slice(i, i + m);
                
                let maxDiff = 0;
                for (let j = 0; j < m; j++) {
                    const diff = Math.abs(currentPattern[j] - comparePattern[j]);
                    maxDiff = Math.max(maxDiff, diff);
                }
                
                if (maxDiff <= r) {
                    similarPatterns.push(i);
                }
            }
            return similarPatterns;
        }
        
        // Draw signal
        function drawSignal(canvasId, signal, color, similarIndices = []) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw signal line
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < N_DISPLAY; i++) {
                const x = (i / N_DISPLAY) * canvas.width;
                const y = canvas.height / 2 - signal[i] * 100;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw analysis window
            ctx.fillStyle = 'rgba(0, 100, 255, 0.1)';
            ctx.strokeStyle = 'rgba(0, 100, 255, 0.3)';
            ctx.setLineDash([3, 3]);
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, (N_ANALYSIS / N_DISPLAY) * canvas.width, canvas.height);
            ctx.fillRect(0, 0, (N_ANALYSIS / N_DISPLAY) * canvas.width, canvas.height);
            ctx.setLineDash([]);
            
            // Add "Analysis Window" text
            ctx.fillStyle = '#0066ff';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Analysis Window', (N_ANALYSIS / N_DISPLAY) * canvas.width / 2, 20);
            
            // Highlight similar patterns
            if (!showResults && highlightIndex < N_ANALYSIS - currentM + 1) {
                // Draw similar patterns in green
                ctx.strokeStyle = '#66bb6a';
                ctx.lineWidth = 4;
                similarIndices.forEach(idx => {
                    if (idx !== highlightIndex) {
                        ctx.beginPath();
                        for (let i = 0; i < currentM; i++) {
                            const x = ((idx + i) / N_DISPLAY) * canvas.width;
                            const y = canvas.height / 2 - signal[idx + i] * 100;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        // Draw circles for pattern points
                        for (let i = 0; i < currentM; i++) {
                            const x = ((idx + i) / N_DISPLAY) * canvas.width;
                            const y = canvas.height / 2 - signal[idx + i] * 100;
                            ctx.fillStyle = '#66bb6a';
                            ctx.beginPath();
                            ctx.arc(x, y, 2.5, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            ctx.strokeStyle = '#66bb6a';
                            ctx.lineWidth = 4;
                        }
                    }
                });
                
                // Draw current pattern in orange
                ctx.strokeStyle = '#ff8a65';
                ctx.lineWidth = 4;
                ctx.beginPath();
                for (let i = 0; i < currentM; i++) {
                    const x = ((highlightIndex + i) / N_DISPLAY) * canvas.width;
                    const y = canvas.height / 2 - signal[highlightIndex + i] * 100;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw circles for current pattern
                for (let i = 0; i < currentM; i++) {
                    const x = ((highlightIndex + i) / N_DISPLAY) * canvas.width;
                    const y = canvas.height / 2 - signal[highlightIndex + i] * 100;
                    ctx.fillStyle = '#ff8a65';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Add "Current" label
                ctx.fillStyle = '#ff8a65';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                const labelX = ((highlightIndex + (currentM - 1) / 2) / N_DISPLAY) * canvas.width;
                ctx.fillText('Current', labelX, 35);
            }
            
            // Draw center line
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
        }
        
        // Update count tables
        function updateCountTables() {
            const sdA = calculateSD(signalA.slice(0, N_DISPLAY));
            const sdB = calculateSD(signalB.slice(0, N_DISPLAY));
            const rA = alpha * sdA;
            const rB = alpha * sdB;
            
            const countsA_m = createPatternCounts(signalA, m, rA);
            const countsA_m1 = createPatternCounts(signalA, m + 1, rA);
            const countsB_m = createPatternCounts(signalB, m, rB);
            const countsB_m1 = createPatternCounts(signalB, m + 1, rB);
            
            // Update table A
            updateTable('tableA-m', countsA_m, currentM === m ? highlightIndex : -1);
            updateTable('tableA-m1', countsA_m1, currentM === m + 1 ? highlightIndex : -1);
            
            // Update table B
            updateTable('tableB-m', countsB_m, currentM === m ? highlightIndex : -1);
            updateTable('tableB-m1', countsB_m1, currentM === m + 1 ? highlightIndex : -1);
            
            // Update r values
            document.getElementById('rAInfo').textContent = rA.toFixed(3);
            document.getElementById('rBInfo').textContent = rB.toFixed(3);
        }
        
        function updateTable(tableId, counts, highlightRow) {
            const tbody = document.querySelector(`#${tableId} tbody`);
            tbody.innerHTML = '';
            
            counts.forEach((data, i) => {
                const row = tbody.insertRow();
                if (i === highlightRow) {
                    row.className = 'highlight';
                }
                row.insertCell(0).textContent = i + 1;
                row.insertCell(1).textContent = data.count;
                row.insertCell(2).textContent = data.C.toFixed(4);
            });
        }
        
        // Update visualization
        function updateVisualization() {
            const sdA = calculateSD(signalA.slice(0, N_DISPLAY));
            const sdB = calculateSD(signalB.slice(0, N_DISPLAY));
            const rA = alpha * sdA;
            const rB = alpha * sdB;
            
            const similarA = findSimilarPatterns(signalA, highlightIndex, currentM, rA);
            const similarB = findSimilarPatterns(signalB, highlightIndex, currentM, rB);
            
            drawSignal('signalA', signalA, '#ef4444', similarA);
            drawSignal('signalB', signalB, '#3b82f6', similarB);
            
            updateCountTables();
            
            if (!showResults) {
                const numPatterns = N_ANALYSIS - currentM + 1;
                document.getElementById('status').textContent = 
                    `Analyzing m=${currentM}, Pattern ${highlightIndex + 1} of ${numPatterns}`;
                
                // Update analysis info
                document.getElementById('currentMInfo').textContent = currentM;
                document.getElementById('currentPatternInfo').textContent = highlightIndex + 1;
                document.getElementById('totalPatternsInfo').textContent = numPatterns;
                document.getElementById('analysisDescription').textContent = 
                    currentM === m ? 
                    `Examining ${m}-point patterns from the analysis window, searching for similar patterns across both signals.` :
                    `Now looking at ${m + 1}-point patterns to see how complexity changes with longer sequences.`;
                
                // Update signal info
                document.getElementById('signalAInfo').children[0].textContent = 
                    `Pattern ${highlightIndex + 1}: Current pattern from analysis window`;
                document.getElementById('signalBInfo').children[0].textContent = 
                    `Pattern ${highlightIndex + 1}: Current pattern from analysis window`;
                
                if (similarA.length > 1) {
                    document.getElementById('signalAMatches').textContent = 
                        `Similar patterns to Pattern ${highlightIndex + 1}: ${similarA.length - 1} matches found`;
                } else {
                    document.getElementById('signalAMatches').textContent = '';
                }
                
                if (similarB.length > 1) {
                    document.getElementById('signalBMatches').textContent = 
                        `Similar patterns to Pattern ${highlightIndex + 1}: ${similarB.length - 1} matches found`;
                } else {
                    document.getElementById('signalBMatches').textContent = '';
                }
            }
            
            // Update info text
            document.getElementById('alphaInfo').textContent = alpha;
            document.getElementById('noiseInfo').textContent = noiseLevel;
        }
        
        // Show results
        function showApEnResults() {
            showResults = true;
            document.getElementById('formulaSection').style.display = 'block';
            document.getElementById('analysisInfo').style.display = 'none';
            document.getElementById('signalAInfo').style.display = 'none';
            document.getElementById('signalBInfo').style.display = 'none';
            
            const sdA = calculateSD(signalA.slice(0, N_DISPLAY));
            const sdB = calculateSD(signalB.slice(0, N_DISPLAY));
            const rA = alpha * sdA;
            const rB = alpha * sdB;
            
            const phiA_m = computeApEn(signalA, m, rA);
            const phiA_m1 = computeApEn(signalA, m + 1, rA);
            const phiB_m = computeApEn(signalB, m, rB);
            const phiB_m1 = computeApEn(signalB, m + 1, rB);
            
            document.getElementById('phiA-m').textContent = phiA_m.toFixed(4);
            document.getElementById('phiA-m1').textContent = phiA_m1.toFixed(4);
            document.getElementById('phiB-m').textContent = phiB_m.toFixed(4);
            document.getElementById('phiB-m1').textContent = phiB_m1.toFixed(4);
            
            document.getElementById('apenA').textContent = (phiA_m - phiA_m1).toFixed(4);
            document.getElementById('apenB').textContent = (phiB_m - phiB_m1).toFixed(4);
            
            document.getElementById('status').textContent = 'Showing Results';
        }
        
        // Animation controls
        function step() {
            const maxIndex = N_ANALYSIS - currentM;
            if (highlightIndex + 1 >= maxIndex) {
                if (currentM === m) {
                    currentM = m + 1;
                    highlightIndex = 0;
                } else {
                    showApEnResults();
                    if (isPlaying) {
                        isPlaying = false;
                        document.getElementById('playBtn').textContent = 'Play';
                        clearInterval(animationInterval);
                    }
                    return;
                }
            } else {
                highlightIndex++;
            }
            updateVisualization();
        }
        
        // Event listeners
        document.getElementById('mSlider').addEventListener('input', function() {
            m = parseInt(this.value);
            document.getElementById('mValue').textContent = m;
            document.querySelectorAll('.m-value').forEach(el => el.textContent = m);
            document.querySelectorAll('.m-plus-value').forEach(el => el.textContent = m + 1);
            reset();
        });
        
        document.getElementById('alphaSlider').addEventListener('input', function() {
            alpha = parseFloat(this.value);
            document.getElementById('alphaValue').textContent = alpha.toFixed(2);
            updateVisualization();
        });
        
        document.getElementById('noiseSlider').addEventListener('input', function() {
            noiseLevel = parseFloat(this.value);
            document.getElementById('noiseValue').textContent = noiseLevel.toFixed(2);
            generateSignals();  // This will only regenerate signal B
            updateVisualization();
        });
        
        document.getElementById('displaySlider').addEventListener('input', function() {
            N_DISPLAY = parseInt(this.value);
            document.getElementById('displayValue').textContent = N_DISPLAY;
            document.getElementById('displayLengthInfo').textContent = N_DISPLAY;
            reset();  // Need to reset when signal length changes
        });
        
        document.getElementById('playBtn').addEventListener('click', function() {
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? 'Pause' : 'Play';
            
            if (isPlaying) {
                animationInterval = setInterval(step, 1000);
            } else {
                clearInterval(animationInterval);
            }
        });
        
        document.getElementById('nextBtn').addEventListener('click', function() {
            if (!showResults) step();
        });
        
        document.getElementById('prevBtn').addEventListener('click', function() {
            if (showResults) {
                showResults = false;
                document.getElementById('formulaSection').style.display = 'none';
                document.getElementById('analysisInfo').style.display = 'block';
                document.getElementById('signalAInfo').style.display = 'block';
                document.getElementById('signalBInfo').style.display = 'block';
                currentM = m + 1;
                highlightIndex = N_ANALYSIS - currentM - 1;
            } else if (highlightIndex > 0) {
                highlightIndex--;
            } else if (currentM === m + 1) {
                currentM = m;
                highlightIndex = N_ANALYSIS - m - 1;
            }
            updateVisualization();
        });
        
        document.getElementById('resetBtn').addEventListener('click', reset);
        
        function reset() {
            currentM = m;
            highlightIndex = 0;
            showResults = false;
            isPlaying = false;
            document.getElementById('playBtn').textContent = 'Play';
            document.getElementById('formulaSection').style.display = 'none';
            document.getElementById('analysisInfo').style.display = 'block';
            document.getElementById('signalAInfo').style.display = 'block';
            document.getElementById('signalBInfo').style.display = 'block';
            clearInterval(animationInterval);
            signalA = [];  // Clear signal A so it gets regenerated
            generateSignals();
            updateVisualization();
            
            // Update info displays
            document.getElementById('displayLengthInfo').textContent = N_DISPLAY;
        }
        
        // Initialize
        generateSignals();
        updateVisualization();
        document.querySelectorAll('.m-value').forEach(el => el.textContent = m);
        document.querySelectorAll('.m-plus-value').forEach(el => el.textContent = m + 1);
    </script>
</body>
</html>
